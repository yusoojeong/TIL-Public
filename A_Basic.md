# basic

## 1. 배열 1 (Array 1)

#### - 알고리즘

> 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
>
> 문제를 해결하기 위한 절차

- 좋은 알고리즘

  - 정확성

  - 작업량 : 작업량多 → CPU↑ → 시간↑

  - 메모리 사용량

  - 단순성

  - 최적성



#### - 배열

> 배열 + 반복문

- 1차원 배열의 접근 : 0부터 시작




#### - 정렬

- 종류
  - O(n^2) : 버블 정렬 / 선택 정렬 / 삽입 정렬
  - O(n+k) : 카운팅 정렬
  - O(nlogn) : 퀵 정렬 / 병합 정렬


#### - 버블 정렬

> 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

- 첫 원소부터 인접한 원소끼리 큰 값을 오른쪽으로 옮기면서 맨 마지막 자리까지 이동

#### - 카운팅 정렬

> 항목들 순서 결정을 위해 집합에 **각 항목이 몇 개 씩 있는지 세는 작업을 하여, 선형 시간**에 정렬하는 효율적인 알고리즘
>

#### - 정렬 알고리즘 비교

- 버블 정렬 : O(n^2). 비교와 교환의 알고리즘. 코딩이 쉬움
- 카운팅 정렬 : O(n+k). 비교환 방식의 알고리즘. n이 작을 때 가능



### - 완전 검색 (Exhaustive Search)

> 문제의 해법으로 생각할 수 있는 **모든 경우의 수를 나열해 확인하는 기법**
>
> Brute-Force 혹은 generate-and-test 기법이라고도 함

- 백트래킹(가지치기)
- 동적계획법(메모이제이션)




### 탐욕(Greedy) 알고리즘

> 최적해를 구하는데 사용하는 **근시안적인 방법**

1. 해 선택 : 현 상태 부분 문제의 최적 해를 구한 뒤, 이를 **부분 해집합**(선택들 집합)에 추가
2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한 지 확인
3. 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지 확인



## 2. 배열 2 (Array 2)

### 1. 2차원 배열

- 델타를 이용한 2차 배열 탐색

- 전치 행렬



### 2. 부분집합 합 문제

> 유한 개 정수로 이루어진 집합에서 부분집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지 알아보는 문제

##### 1. 부분집합 생성하기

- 부분 집합의 수 : 원소 n개면, 공집합 포함 2^n개

- 부분집합 생성하기


##### 2. 비트 연산자

- `&` 비트 단위로 AND 연산
- `|` 비트 단위로 OR 연산
- `<<`  피연산자의 비트열을 왼쪽 이동
- `>>`  피연산자의 비트열을 오른쪽 이동
- `^` XOR (두 수가 같으면 0, 다르면 1)

- 보다 간결하게 부분집합 생성




### 3. 검색 (search)

> 저장된 자료 중 원하는 항목을 찾는 작업
>
> 목적하는 탐색 키를 가진 항목 찾기

##### - 순차 검색 (sequential search) `O(n)`

> 일렬로 되어 있는 자료를 순서대로 검색.
>
> 가장 간단, 직관적 검색 방법 - 검색 대상 수↑ → 수행시간↑
>
> 배열이나 연결 리스트 등 순차구조에 유용

- 정렬되어 있지 않은 경우 `O(n)`

- 정렬 되어 있는 경우 `O(n)`

##### - 이진 검색 (binary search) `O(logn)`

- 자료가 *정렬된 상태* 여야 함

- 자료의 가운데 있는 항목의 키 값과 비교하여 다음 검색 위치 결정

- 검색 범위의 시작점과 종료점을 이용해 검색 반복 수행


##### - 해쉬 (hash) `O(1)`. but 메모리 ↑

- 메모리가 들어갈 공간 테이블을 만들어 둠
- key 값이 들어오면 있어야할 위치로 매핑(해시함수 이용)
  - 해시함수는 산술 연산.
  - 범위 안에 들어오는 수로 만들기 위해 모듈러(?) 연산



### 4. 인덱스

> Database에서 유래. 테이블에 대한 동작 속도를 높여주는 자료 구조



### 5. 선택 정렬 (Selection Sort) `O(n^2)`

> 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환
>
> - 정렬 과정
>   - 주어진 리스트 중 최소값 찾기
>   - 해당 값을 리스트 맨 앞에 위치한 값과 교환
>   - 맨 처음 위치 제외한 나머지 리스트 대상으로 과정 반복

- 셀렉션 알고리즘

  > 저장된 자료에서 k번째로 큰 or 작은 원소를 찾는 방법
  >
  > 선택 정렬과 같지만 0부터 k까지(k-1까지만 확인)만 진행 후 return list[k-1]



## 3. 문자열 (String)

### 1. 문자열

- 출력 가능 아스키 문자(32 ~ 126)

- 유니코드 : 다국어 처리

  - 다시 Character Set으로 분류. 바이트 순서 표준화 X
  - 적당한 외부 인코딩 필요

- big-endian, little-endian

- 파이썬

  - 다른 문자와 달리 파이썬은 char타입 없음
  - 텍스트 데이터 취급방법이 통일

- 프로그래밍 언어 string 처리의 기본적인 차이점

  - c는 아스키 코드 저장
  - java는 유니코드(UTF16, 2byte) 저장
  - 파이썬은 유니코드(UTF8) 저장

  

### 2. 패턴 매칭 알고리즘

#### - 고지식한 패턴 검색 알고리즘

> 본문 문자열을 처음부터 끝까지 차례로 순회하면서 패턴 내 문자들을 일일이 비교

#### - KMP 알고리즘

>불일치 발생한 텍스트 스트링 앞부분에 어떤 문자가 있는지를 미리 알고 있으므로, **불일치가 발생한 앞부분에 대해 다시 비교하지 않고**(Brute Force처럼 하지 않겠다) 매칭 수행

#### - 보이어-무어 알고리즘

> 오른쪽에서 왼쪽으로 비교
>
> 상용 소프트웨어 채택
>
> 오른쪽 끝 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 패턴 길이 만큼



## 4. Stack1

### 1. 스택

> 자료를 쌓아 올린 형태의 자료구조
>
> 선형구조 (1대 1)
>
> 후입선출(LIFO)

- 연산 : 삽입(push) / 삭제(pop) / 공백확인(isEmpty) / top의 item 반환(peek)

#### - 스택의구현

- push

- pop

- 스택 구현 고려 사항

  - 1차원 배열 : 구현 쉽지만 스택 크기 변경이 어려움

#### - 스택의 응용1 : 괄호검사

#### - 스택의 응용2 : function call



### 2. 재귀호출

> 자기 자신을 호출



### 3. Memoization

> 중복 호출하는 부분을 방지하기 위해 메모리 공간에 저장하는 방식
>
> 시간 복잡도 O(n)



### 4. DP (Dynamic Programming)

> 동적  계획 알고리즘은 최적화 문제 해결 알고리즘
>
> 입력 크기가 작은 부분 문제들을 모두 해결한 후 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하는 방식



### 5. 그래프

> 정점(Vertex)들의 집합과 연결하는 간선(Edge)들의 집합으로 구성된 자료

- 유형
- 무향(화살표X) / 유향(화살표O) / 가중치 / 사이클 없는 방향 그래프
- 인접리스트 저장
- 2차 배열 형태로 해서 저장하는 형식



### - 백트래킹

> 해를 찾는 도중에 **막히면(해가 아니면) 되돌아가서 다시 해를 찾아** 가는 기법
>
> 최적화 문제와 결정 문제 해결할 수 있음
>

#### - 백트래킹과 깊이우선탐색 차이

- prunning 가지치기
- DFS은 모든 경로 추적 / 백트래킹은 불필요한 경로 차단
- DFS를 하기엔 경우의 수 너무 많음.
- 백트래킹은 경우의 수 줄어들지만 최악의 경우 여전히 지수함수 시간 요함



## 6. Queue (큐)

### 큐 (Queue)

> 삽입, 삭제 위치가 제한적인 자료구조
>
> 선입선출구조(FIFO: First In First Out)

- 기본 연산
  - 삽입 : enQueue
  - 삭제 : deQueue
  - 빈 큐 생성 : createQueue()
  - 공백 확인 : isEmpty()
  - 포화상태 확인 : isFull()
  - 큐 앞쪽(front)에서 원소 삭제없이 반환 : Qpeek()

#### 큐의 구현

- 구현 방식

  > 1. front : 꺼내진 위치 / rear : 저장한 위치.

>front = rear = -1 로 초기화
>
>4. front를 1 증가시켜서 값을 꺼냄



#### 선형 큐 (1차원 배열)

- front : 저장된 첫 번째 원소의 인덱스 -> 마지막으로 꺼낸 위치
- rear : 저장된 마지막 원소의 인덱스 -> 마지막으로 저장된 자리

#### 원형 큐



#### 연결 큐 (B형 - Linked List)

> 단순 연결 리스트(Linked List)를 이용한 큐 - Linked List 배운 후에 이해가 더 잘 될 것.



#### 우선순위 큐(Priority Queue)

> 우선순위 가진 항목들을 저장하는 큐
>
> 우선순위가 높은 순서대로 먼저 나가게 됨



#### 큐의 활용 : 버퍼(Buffer)

- 버퍼

  > 데이터를 한 곳 - 다른 곳 으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역



### deque 을 쓰는 것이 좀 더 빠름

- deque()는 앞에 넣을 수도 있고 뒤에 넣을 수도 있음(입,출구가 양쪽)



### BFS (Breadth First Search)

> 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후, 방문했던 정점을 시작점으로 하여 다시 정점들을 차례로 방문하는 방식



## 7. Linked List (연결 리스트)

## 리스트(List)

> 순서를 가진 데이터 집합 - 추상 자료형
>
> 동일한 데이터를 가지고 있어도 상관 없다.
>
> - 구현 방법
>   - 순차 리스트 : 배열 기반 (연속적 메모리 공간)
>   - 연결 리스트 : 메모리 동적할당 기반

### 2. 연결 리스트(Linked List)

> 원하는 인덱스를 바로 찾아갈 수는 없음
>
> - 자료의 논리적 순서와 메모리 상 물리적 순서가 일치 X
> - 개별적으로 위치하고 있는 원소 주소를 연결함 (링크 통해 원소 접근)

#### - 연결 리스트의 기본 구조

- 노드 

  - 구성 요소
    1. 데이터 필드
    2. 링크 필드

- 헤드


#### - 이중 연결 리스트(Doubly Linked List)

> 양 방향 순회 되도록 두 개의 링크 필드(앞 뒤)와 데이터 필드 가진 구조



## 8. Tree

### 트리

> 비선형 구조 (넓은 의미에서 그래프. 다소 차이는 있음)
>
> 원소들 간 1:n, 계층관계(부모1 - 자식 多) 가지는 계층형 자료구조
>

### 이진 트리

> 모든 노드들이 최대 2개의 서브트리를 갖는 특별한 형태의 트리
>

##### - 포화 이진 트리(Full Binary Tree)

##### - 완전 이진 트리 (Complete Binary Tree)

##### - 편향 이진 트리 (Skewed Binary Tree)



### 힙

> **완전 이진 트리**에 있는 노드 중 키 값이 가장 큰 or 작은 노드를 찾기 위해 만든 자료 구조